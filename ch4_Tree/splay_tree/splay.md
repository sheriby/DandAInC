## Splay Tree ————伸展树

### 伸展树的基本介绍

伸展树和平衡树的目的是一样的，尽量降低对树的操作的时间复杂度。（最好是O(logN)， 最差是O(N)）。
先假设存在一个不平衡的二叉树的某个节点的操作的时间复杂度是O(N)，那么我们对其进行M次访问，那么时间
复杂度就是O(MN)，效率非常的低下。虽然我们可以将树变成AVL解决这个问题，但是变成AVL这个操作也是非常麻烦
而且费时的。

伸展树也是来解决这个问题的。伸展树基于这样的一个事实，O(N)的时间并不是太坏，只要它不经常发生就是了。虽然
我们对树的有些操作是O(N)的，但是大部分的操作还是O(logN)，这样的操作还是很快。

伸展树的实现如下：当一个节点被访问的时候，他就必须要经过一系列的AVL旋转操作旋转到根上。否则如果这个节点很深，
我们可能不断的对它进行find操作，这样效率就变低了。

### 伸展树如何旋转

从上到下，被`find`的节点一直和它的父节点进行单旋转。
节点的右节点通过左旋转可以旋转到节点的位置，同样我们要对节点的左节点进行右旋转。
直到被`find`的节点被旋转到了根节点的位置就行了。
下次我们如果还要访问该节点的话，就可以直接访问到。（事实上，通过一系列的这些操作，经常被访问的节点将会在前面，
而不经常被访问的节点会在下面，极大的提高了访问的效率，有点像之前写过的那个自调整表）

### 需要注意的地方

虽然使用上面的方法可以讲某个节点推向树根的位置，使得该节点的访问暂停变得容易，但是同时将另外的一个节点推倒了
这个节点之前几乎同样深的地方，使得该节点的访问暂时变得困难。

### 另一种想法————展开
展开类似之前的旋转的方法，但是在旋转如何实施上我们稍微有些选择的余地。
对于不同的情况下，我们做的旋转操作也是不同的。
假设我们要寻找的节点是x,他的父节点是p，父节点的父节点也就是祖父节点是g。

- 当不存在祖父节点时，也就是p就是根节点，此时我们只需要就行一次旋转就行了。
- 当x, p, g三个节点呈之字形时，旋转的操作和之前是相同的。
- 当x, p, g三个节点呈一字型时，我们需要进行特殊的处理。
    如旋转之前的树的先序遍历是 g p x a b c d， 旋转之后将变成 x a p b g c d
    以p，x都在左子树也就是一字型向左为例，具体操作如下。
    x节点right指向父节点g； 
    父节点p的right指向祖父节点g，父节点p的left指向原来的right；
    祖父节点g的left指向父节点p原来的right，祖父节点g的right指向不变。

通过这三种不同的旋转方案，我们可以更好的降低树的深度。
不过这也不一定能够降低树的深度，对于一颗非常不平衡的树通过上面的多次旋转操作会趋于平衡，但是
如果这颗树本来就是一颗非常平衡的树，那么我们做的这些旋转反而会降低树的效率。
不过要是从平均时间上来看，伸展树还是极大的提高了效率。
