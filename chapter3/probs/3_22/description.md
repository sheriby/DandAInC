## 第三章 习题 3-22

### 问题描述

提出支持栈的`Push`，`Pop`以及第三种`FindMin`操作的数据结构，这三种操作在最坏的情况下的时间
复杂度也是`O(1)`

### 个人想法

刚看到这个题目的时候我的第一反应是`最小堆`，最小堆可以一直`FindMin`，也同样可以往堆中放置和取出元素，
这不过和栈似乎一点都不一样。

本来我是想这样子做的，在栈中记录最小的值。
```c
    typedef struct {
        ElementType* element;
        ElementType minElement;
    }
```
但是还是我太年轻了。这样子的话，如果栈中最小的元素被pop出去了，此时`minElement`又该等于多少呢？？

这个问题需要使用两个栈来解决。
一个栈就是存放所有的元素，另一个栈用来存放较小的元素。

### 我的答案

主要也是参考了书的答案的。
使用一个数据结构`F`维护两个栈。其中一个栈`E`就是执行`push`和`pop`用的存放数据，另一个栈`M`用来`findMin`。

具体操作过程如下：
当我们调用`push(X, F)`的时候，首先会看看`M`是否为空，如果为空或者说`X的值小于等于M栈顶的值`，那么`push(X, M)`。
然后，`push(X, E)`。（先要保证栈没有满）
当我们调用`pop(X)`的时候，观察`E和M栈顶是否是相同的`，如果是相同的，两个栈同时pop，否则只有E进行pop处理。
当我们调用`findMin(X)`的时候，直接返回`top(X, M)`就完事了，因为M栈的栈顶保存的就是栈中最小的元素。


