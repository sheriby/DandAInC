## Splay Tree ————伸展树

### 伸展树的基本介绍

伸展树和平衡树的目的是一样的，尽量降低对树的操作的时间复杂度。（最好是O(logN)， 最差是O(N)）。
先假设存在一个不平衡的二叉树的某个节点的操作的时间复杂度是O(N)，那么我们对其进行M次访问，那么时间
复杂度就是O(MN)，效率非常的低下。虽然我们可以将树变成AVL解决这个问题，但是变成AVL这个操作也是非常麻烦
而且费时的。

伸展树也是来解决这个问题的。伸展树基于这样的一个事实，O(N)的时间并不是太坏，只要它不经常发生就是了。虽然
我们对树的有些操作是O(N)的，但是大部分的操作还是O(logN)，这样的操作还是很快。

伸展树的实现如下：当一个节点被访问的时候，他就必须要经过一系列的AVL旋转操作旋转到根上。否则如果这个节点很深，
我们可能不断的对它进行find操作，这样效率就变低了。

### 伸展树如何旋转

从上到下，被`find`的节点一直和它的父节点进行单旋转。
节点的右节点通过左旋转可以旋转到节点的位置，同样我们要对节点的左节点进行右旋转。
直到被`find`的节点被旋转到了根节点的位置就行了。
下次我们如果还要访问该节点的话，就可以直接访问到。（事实上，通过一系列的这些操作，经常被访问的节点将会在前面，
而不经常被访问的节点会在下面，极大的提高了访问的效率，有点像之前写过的那个自调整表）

### 需要注意的地方

虽然使用上面的方法可以讲某个节点推向树根的位置，使得该节点的访问暂停变得容易，但是同时将另外的一个节点推倒了
这个节点之前几乎同样深的地方，使得该节点的访问暂时变得困难。